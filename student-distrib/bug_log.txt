****************************************** BUG LOG *******************************************
-----------------
TEMPLATE: 
-----------------
FILE/FUNCTION: 
BUG: 
SOLUTION:
DIFFICULTY:
-----------------

**************************************** CHECKPOINT 2 ****************************************
-----------------
FILE/FUNCTION: file_read()
BUG: The file that we were trying to access was always showing as unavailable/invalid. 
SOLUTION: We were setting the flags incorrectly in the file descriptor. However, we realized that our file descriptor idea was incorrect so we just ended up redoing it.
DIFFICULTY: 45 minutes
-----------------
FILE/FUNCTION: Testing file_read with executables
BUG: When using file read with the 'grep' executable, the program printed out errors about not being able to read the file. 
SOLUTION: The 'grep' executable does actually have those characters, and was too large to be printed onto the screen. We switched to printing the 'hello' executable instead.
DIFFICULTY: 30 minutes
-----------------
FILE/FUNCTION: read_data()
BUG: The read_data() function would only read a few bytes from the file and then stop.
SOLUTION: We realized that we were not incrementing the current byte index correctly. We stopped it at length, instead of length + offset.
DIFFICULTY: 10 minutes
-----------------
FILE/FUNCTION: terminal/keyboard writing
BUG: moving text up for new line causing weird graphical errors
DIFFICULTY: 30 min
SOLUTION: when I tried to move the screen up the entire screen would change color and fill with random characters. I realized that when I
was rewriting bytes in video memory to move the characters up, I was writing byte by byte instead of every other byte. This caused the colors
to change because the 2nd byte is the color of that character. To fix this I changed every other byte in my iteration.
-----------------
FILE/FUNCTION: rtc_write
BUG: the rtc tests where not going to the frequency I was setting it to
DIFFICULTY: 1 hr
SOLUTION: I was using an unsigned char to store the input frequency which was limiting it to 255 Hz. To fix this bug I replaced it with an int
to hold all inputs from 2-1024 Hz.
-----------------
FILE/FUNCTION: terminal/keyboard roles
BUG: More of a conceptual misunderstanding of what terminal should do
DIFFICULTY: 3 hrs
SOLUTION: I initially used the terminal to handle the printing and did not even have a buffer. Once we realized that terminal was supposed to maintain
the buffer and keyboard is meant to do more of the printing, we had to re-organize our code and add the buffer along with checks for proper handling.
-----------------

**************************************** CHECKPOINT 1 ****************************************
-----------------
FILE/FUNCTION: x86_desc.S
BUG: Kernel kept looping over and over again.
SOLUTION: GDT wasn't loaded correctly (we were using the wrong descriptor pointer with the lgdt command).
DIFFICULTY: 2 hours
-----------------
FILE/FUNCTION: rtc.c - handler
BUG: rtc was not never interrupting and calling the handler.
SOLUTION: We realized that we had done everything right, but had not enabled irq2 on 
the primary PIC, after enabling irq0 on the secondary.
-----------------
FILE/FUNCTION: asm_linkage.S - keyboard.c/h
BUG: Our keyboard was only recieving the very first input interrupt, then not getting anymore.
SOLUTION: We had not created the ASM linkage for the interrupts, causing the interrupt flag to 
prevent more interrupts each time an interrupt was called. We added the linkage code to call
iret, causing the orginal eflags to be set and allow more interrupts.
-----------------
FILE/FUNCTION: paging_asm.S
BUG: Saying there was an implicit declaration for function when we clearly had created the functions.
SOLUTION: It turns out that having the same assembly file name as your header file does not work. So, we changed paging.S to paging_asm.S
-----------------
FILE/FUNCTION: paging.c/h - setup
BUG: Our code was crashing right when we started. the values in our assembly code was incorrect.
SOLUTION: We realized that we where passing the incorrect values of memory to the assembly functions, causing it to map incorrectly.
We had to use &page_dir instead of just page_dir.
-----------------
FILE/FUNCTION: keyboard.c
BUG: After we press a key on the keyboard, letting go would also trigger an interrupt and print a character.
SOLUTION: To fix this error we realized that the let go characters where the pressed char + 128, so we just
did a check to filter out higher idx characters.
-----------------
FILE/FUNCTION: keyboard.c
BUG: Keyboard receiving inputs but only printing out numbers instead of characters.
SOLUTION: Had to map the corresponding values received from the interrupt into the correct keyboard characters. We used a char
array and indexed the numbers printed out to corresponding keyboard characters.
-----------------
FILE/FUNCTION: idt.c
BUG: Double fault error keeps happening when loading idt.
SOLUTION: We forgot to actually initialize the idt itself in the kernel.c file, which caused a double fault (found through GDB).
DIFFICULTY: 2 hours
-----------------

**************************************** CHECKPOINT 5 ****************************************
-----------------
FILE/FUNCTION:
BUG:
DIFFICULTY: 
SOLUTION:
-----------------
**************************************** CHECKPOINT 4 ****************************************
-----------------
FILE/FUNCTION:
BUG:
DIFFICULTY: 
SOLUTION:
-----------------
**************************************** CHECKPOINT 3 ****************************************
-----------------
FILE/FUNCTION: syscall.c
BUG: Test cases do not properly call terminal_read and terminal_write.
DIFFICULTY: 2 hours
SOLUTION: We were checking to make sure if fd was >= 2 which was incorrect since stdin and stdout are 0 and 1 respectively.
-----------------
- fourth character gets replaced by a NULL
- ls program only prints the first line
- ls program prints the correct lines, returns 0, then page faults
- opening shell within shell doesn't do anything
-----------------
FILE/FUNCTION: syscall.c 
BUG: halt causing a page fault
DIFFICULTY: 1 day
SOLUTION: Incorrect usage and understanding of IRET vs RET in asm volatile. Calling ret and returning to previous process
frame when there are still remaining processes. Then IRET is used when there are no processes remaining and we are in the base frame.
-----------------
